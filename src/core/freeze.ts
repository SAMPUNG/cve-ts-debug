import { ToClientMessageType } from '@cve-ts/dictionary'
import {
  onResizePlayerStyle,
  playVideoStream,
  video,
  wrapper,
} from '@cve-ts/player'

import { setUETimings } from './latency'
import refs from '../refs/instance'
import { updateVideoEncoderQP } from './stats'

let editTextButton: HTMLButtonElement
let height: number = 0
let hiddenInput: HTMLInputElement
let jpeg: Uint8Array | undefined = undefined
let overlay: HTMLElement
let receiving: boolean = false
let size: number = 0
let valid: boolean = false
let width: number = 0

export function createOnScreenKeyboardHelpers() {
  // On a touch device we will need special ways to show the on-screen keyboard.
  if ('ontouchstart' in document.documentElement) {
    if (document.getElementById('hidden-input') === null) {
      hiddenInput = document.createElement('input')
      hiddenInput.id = 'hidden-input'
      hiddenInput.maxLength = 0
      wrapper.appendChild(hiddenInput)
    }

    if (document.getElementById('edit-text-button') === null) {
      editTextButton = document.createElement('button')
      editTextButton.id = 'edit-text-button'
      editTextButton.innerHTML = 'edit text'
      wrapper.appendChild(editTextButton)

      // Hide the "edit text" button.
      editTextButton.classList.add('hidden-state')

      editTextButton.addEventListener('click', () => {
        // Show the on-screen keyboard.
        hiddenInput.focus()
      })
    }
  }
}

export function invalidateFreezeFrameOverlay() {
  overlay.style.display = 'none'
  valid = false
  overlay.classList.remove('freezeframe-background')

  setVideoEnabled(true)
}

export function onDataChannelMessage(data: ArrayBuffer) {
  const view = new Uint8Array(data)
  if (receiving && jpeg) {
    jpeg = new Uint8Array(jpeg.length + view.length)
    jpeg.set(jpeg, 0)
    jpeg.set(view, jpeg.length)
    if (jpeg.length === size) {
      receiving = false
      valid = true
      console.log(`received complete freeze frame ${size}`)
      showFreezeFrame()
    } else if (jpeg.length > size) {
      console.error(
        `received bigger freeze frame than advertised: ${jpeg.length}/${size}`
      )
      jpeg = undefined
      receiving = false
    } else {
      console.log(
        `received next chunk (${view.length} bytes) of freeze frame: ${jpeg.length}/${size}`
      )
    }
  } else if (view[0] === ToClientMessageType.QualityControlOwnership) {
    const ownership = view[1] !== 0
    console.log(
      `Received quality controller message, will control quality: ${ownership}`
    )
  } else if (view[0] === ToClientMessageType.Response) {
    // TODO
  } else if (view[0] === ToClientMessageType.Command) {
    const commandAsString = new TextDecoder('utf-16').decode(data.slice(1))
    console.log(commandAsString)
    const command = JSON.parse(commandAsString)
    if (command.command === 'onScreenKeyboard') {
      showOnScreenKeyboard(command)
    }
  } else if (view[0] === ToClientMessageType.FreezeFrame) {
    processFreezeFrameMessage(view)
  } else if (view[0] === ToClientMessageType.UnfreezeFrame) {
    invalidateFreezeFrameOverlay()
  } else if (view[0] === ToClientMessageType.VideoEncoderAvgQP) {
    updateVideoEncoderQP(
      Number(new TextDecoder('utf-16').decode(data.slice(1)))
    )
  } else if (view[0] == ToClientMessageType.LatencyTest) {
    const latencyTimingsAsString = new TextDecoder('utf-16').decode(
      data.slice(1)
    )
    console.log('Got latency timings from UE.')
    console.log(latencyTimingsAsString)
    const latencyTimingsFromUE = JSON.parse(latencyTimingsAsString)
    setUETimings(latencyTimingsFromUE)
  } else if (view[0] == ToClientMessageType.InitialSettings) {
    const settingsString = new TextDecoder('utf-16').decode(data.slice(1))
    const settingsJSON = JSON.parse(settingsString)

    // reminder bitrates are sent in bps but displayed in kbps

    if (settingsJSON.Encoder) {
      refs['encoder-rate-control'].value = settingsJSON.Encoder.RateControl
      refs['encoder-target-bitrate-text'].value =
        settingsJSON.Encoder.TargetBitrate > 0
          ? settingsJSON.Encoder.TargetBitrate / 1000
          : settingsJSON.Encoder.TargetBitrate

      refs['encoder-max-bitrate-text'].value =
        settingsJSON.Encoder.MaxBitrate > 0
          ? settingsJSON.Encoder.MaxBitrate / 1000
          : settingsJSON.Encoder.MaxBitrate

      refs['encoder-min-qp-text'].value = settingsJSON.Encoder.MinQP
      refs['encoder-max-qp-text'].value = settingsJSON.Encoder.MaxQP
      refs['encoder-filler-data-tgl'].checked =
        settingsJSON.Encoder.FillerData === 1
      refs['encoder-multipass'].value = settingsJSON.Encoder.MultiPass
    }
    if (settingsJSON.WebRTC) {
      refs['webrtc-degradation-pref'].value =
        settingsJSON.WebRTC.DegradationPref
      refs['webrtc-max-fps-text'].value = settingsJSON.WebRTC.MaxFPS
      refs['webrtc-min-bitrate-text'].value = (
        settingsJSON.WebRTC.MinBitrate / 1000
      ).toString()

      refs['webrtc-max-bitrate-text'].value = (
        settingsJSON.WebRTC.MaxBitrate / 1000
      ).toString()

      refs['webrtc-low-qp-text'].value = settingsJSON.WebRTC.LowQP
      refs['webrtc-high-qp-text'].value = settingsJSON.WebRTC.HighQP
    }
  } else {
    console.error(`unrecognized data received, packet ID ${view[0]}`)
  }
}

function processFreezeFrameMessage(view: Uint8Array) {
  // Reset freeze frame if we got a freeze frame message and we are not "receiving" yet.
  if (!receiving) {
    receiving = true
    valid = false
    size = 0
    jpeg = undefined
  }

  // Extract total size of freeze frame (across all chunks)
  size = new DataView(view.slice(1, 5).buffer).getInt32(0, true)

  // Get the jpeg part of the payload
  const jpegBytes = view.slice(1 + 4)

  // Append to existing jpeg that holds the freeze frame
  if (jpeg) {
    jpeg = new Uint8Array(jpeg.length + jpegBytes.length)
    jpeg.set(jpeg, 0)
    jpeg.set(jpegBytes, jpeg.length)
  }
  // No existing freeze frame jpeg, make one
  else {
    jpeg = jpegBytes
    receiving = true
    console.log(`received first chunk of freeze frame: ${jpeg.length}/${size}`)
  }

  // Uncomment for debug
  // console.log(`Received freeze frame chunk: ${freezeFrame.jpeg.length}/${freezeFrame.size}`);

  // Finished receiving freeze frame, we can show it now
  if (jpeg.length === size) {
    receiving = false
    valid = true
    console.log(`received complete freeze frame ${size}`)
    showFreezeFrame()
  }
  // We received more data than the freeze frame payload message indicate (this is an error)
  else if (jpeg.length > size) {
    console.error(
      `received bigger freeze frame than advertised: ${jpeg.length}/${size}`
    )
    jpeg = undefined
    receiving = false
  }
}

export function resizeFreezeFrameOverlay() {
  if (width !== 0 && height !== 0) {
    let displayWidth = 0
    let displayHeight = 0
    let displayTop = 0
    let displayLeft = 0
    const checkBox = document.querySelector<HTMLInputElement>(
      '#enlarge-display-to-fill-window-tgl'
    )
    if (checkBox !== null && checkBox.checked) {
      // We are fitting video to screen, we care about the screen (window) size
      const windowAspectRatio = window.innerWidth / window.innerHeight
      const videoAspectRatio = width / height
      if (windowAspectRatio < videoAspectRatio) {
        displayWidth = window.innerWidth
        displayHeight = Math.floor(window.innerWidth / videoAspectRatio)
        displayTop = Math.floor((window.innerHeight - displayHeight) * 0.5)
        displayLeft = 0
      } else {
        displayWidth = Math.floor(window.innerHeight * videoAspectRatio)
        displayHeight = window.innerHeight
        displayTop = 0
        displayLeft = Math.floor((window.innerWidth - displayWidth) * 0.5)
      }
    } else {
      // Video is coming in at native resolution, we care more about the renderer size
      const playerAspectRatio = wrapper.offsetWidth / wrapper.offsetHeight
      const videoAspectRatio = width / height
      if (playerAspectRatio < videoAspectRatio) {
        displayWidth = wrapper.offsetWidth
        displayHeight = Math.floor(wrapper.offsetWidth / videoAspectRatio)
        displayTop = Math.floor((wrapper.offsetHeight - displayHeight) * 0.5)
        displayLeft = 0
      } else {
        displayWidth = Math.floor(wrapper.offsetHeight * videoAspectRatio)
        displayHeight = wrapper.offsetHeight
        displayTop = 0
        displayLeft = Math.floor((wrapper.offsetWidth - displayWidth) * 0.5)
      }
    }
    const ffOverlay = document.getElementById('overlay')!
    const freezeFrameImage = ffOverlay.childNodes[0] as HTMLImageElement
    overlay.style.width = `${wrapper.offsetWidth}px`
    overlay.style.height = `${wrapper.offsetHeight}px`
    overlay.style.left = `${0}px`
    overlay.style.top = `${0}px`

    freezeFrameImage.style.width = `${displayWidth}px`
    freezeFrameImage.style.height = `${displayHeight}px`
    freezeFrameImage.style.left = `${displayLeft}px`
    freezeFrameImage.style.top = `${displayTop}px`
  }
}

function setVideoEnabled(enabled: boolean) {
  const media = video.srcObject as MediaStream
  media.getTracks().forEach((track) => (track.enabled = enabled))
}

export function setupFreezeFrameOverlay() {
  overlay = document.createElement('div')
  overlay.id = 'overlay'
  overlay.style.display = 'none'
  overlay.style.pointerEvents = 'none'
  overlay.style.position = 'absolute'
  overlay.style.zIndex = '20'
  const freezeFrameImage = document.createElement('img')
  freezeFrameImage.style.position = 'absolute'
  overlay.appendChild(freezeFrameImage)
}

function showFreezeFrame() {
  if (!jpeg) {
    return
  }
  const base64 = btoa(
    jpeg.reduce((data, byte) => data + String.fromCharCode(byte), '')
  )
  const ffOverlay = document.getElementById('overlay')!
  const image = ffOverlay.childNodes[0] as HTMLImageElement
  image.src = `data:image/jpeg;base64,${base64}`
  image.onload = () => {
    height = image.naturalHeight
    width = image.naturalWidth
    resizeFreezeFrameOverlay()
    // TODO: if ('debug-panel') {
    if (wrapper) {
      showPlayOverlay()
      onResizePlayerStyle()
    } else {
      showFreezeFrameOverlay()
    }
    setVideoEnabled(false)
  }
}

export function showFreezeFrameOverlay() {
  if (valid) {
    overlay.classList.add('freezeframe-background')
    overlay.style.display = 'block'
  }
}

function showOnScreenKeyboard(command: ScreenCommand) {
  if (command.showOnScreenKeyboard) {
    // Show the "edit text" button.
    editTextButton.classList.remove('hidden-state')
    // Place the "edit text" button near the UE4 input widget.
    const pos = unquantizeAndDenormalizeUnsigned(command.x, command.y)
    editTextButton.style.top = `${pos.y.toString()}px`
    editTextButton.style.left = `${(pos.x - 40).toString()}px`
  } else {
    // Hide the "edit text" button.
    editTextButton.classList.add('hidden-state')
    // Hide the on-screen keyboard.
    hiddenInput.blur()
  }
}

export function showPlayOverlay() {
  playVideoStream()

  const classList = refs['cve-player-debug-panel'].classList
  classList.toggle('overlay-collapse', false)
}

function unquantizeAndDenormalizeUnsigned(x: number, y: number) {
  const playerAspectRatio = wrapper.clientHeight / wrapper.clientWidth
  const videoAspectRatio = video.videoHeight / video.videoWidth
  const playerBiggerThanVideo = playerAspectRatio > videoAspectRatio

  const ratio = playerBiggerThanVideo
    ? playerAspectRatio / videoAspectRatio
    : videoAspectRatio / playerAspectRatio
  const normalizedX = playerBiggerThanVideo
    ? x / 65536
    : (x / 65536 - 0.5) / ratio + 0.5
  const normalizedY = playerBiggerThanVideo
    ? (y / 65536 - 0.5) / ratio + 0.5
    : y / 65536
  return {
    x: normalizedX * wrapper.clientWidth,
    y: normalizedY * wrapper.clientHeight,
  }
}
